### static 和 final 关键字
1. static关键字
    一、static的使用
    1、static用于修饰成员变量和成员方法，称之为静态变量和静态方法，可以直接通过类名访问。
    2、static修饰的代码块称之为静态代码块，在类加载期间就会执行代码块内容。

    二、static变量
    static修饰的变量称之为静态变量，没有用static修饰的变量称之为实例变量
    
    （1）静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且 JVM 也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。
    （2）实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。
    
    三、static方法
    static修饰的方法称之为静态方法，通过类名之间调用，不依赖与任何实例；
    
    四、static代码块
    被 static 修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。
    
    五、static的局限性
    （1）它只能调用static变量
    （2）不能以任何形式引用this、super
    （3）static 变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。

2. final关键字
    使用到final的有三种情况：变量、方法和类；
    
    一、final变量：它修饰的变量在初始化后不能再修改了
    （1）编译期常量：
    它在类加载的过程就已经完成了初始化，所以当类加载完成后是不可更改的，对于编译期常量，只能使用基本类型，而且必须要在定义时进行初始化。
    （2）运行期常量
    对于运行期常量，它既可是基本数据类型，也可是引用数据类型。基本数据类型不可变的是其内容，而引用数据类型不可变的是其引用，引用所指定的对象内容是可变的。
    
    二、final方法
    final修饰的方法不能被重新
    
    三、final类
    final休息的类不能够被继承
    
    四、final修饰的参数，表示该参数是不可变的
    在内部类中，final是很有用的；如果我们定义了一个匿名内部类，并且希望使用一个外部类的参数，该参数要加final关键字修饰；为了避免引用值发生改变，
    例如被外部类的方法修改等，而导致内部类得到的值不一致；
    

### synchronized加在static方法和非static方法上区别
- 表示此时的lock锁对象不一样，static 方法的锁是当前类的Class对象，而非static方法的锁是当前调用该方法的对象，它们之间不会产生互斥

### String、StringBuffer、StringBuilder区别，StringBuilder 的使用场景不知道
1. String 是java非常基础和重要的类，提供了构造和管理字符串的基本功能，它被声明为 final 类型的类，属性也是 final 的。在实际开发中使用的很频繁。<br/>
(1) java 避免系统产生大量的 String 对象，引入了字符串常量池(属于jvm内存模型的方法区)的概念。其运行机制是：首先检查池中是否有值相同的字符串对象，
如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。该原则只适用于通过直接量给String对象引用赋值的情况。
对于通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。<br/>
(2) String对象一旦生成，则不能再对它进行改变,保证了被多线程读取后内容不变

2. StringBuffer 和 StringBuilder，底层的存储结构和 String 都是一样的，使用的是char数组；不同点是StringBuffer/StringBuilder对象的值是可以改变；
3. StringBuffer是线程安全的，而StringBuilder是线程不安全的，StringBuffer类中方法定义前面都会有synchronize关键字。为此，StringBuffer的性能要远低于StringBuilder。

4. 应用场景
(1) 在字符串内容不经常发生变化的业务场景优先使用String类。字符串拼接避免使用 "+",会产生大量无用的中间对象，消耗内存空。<br/>
(2) 频繁的字符串操作的情况使用 StringBuffer(多线程时使用) 和 StringBuilder(单线程时使用)

